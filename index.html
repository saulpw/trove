<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>trove</title>
  <style>
    body { font-family: system-ui, sans-serif; max-width: 800px; margin: 2rem auto; padding: 0 1rem; }
    header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; }
    header h1 { margin: 0; }
    header h1 a { color: inherit; text-decoration: none; }
    header h1 a:hover { text-decoration: underline; }
    #auth-container { font-size: 0.9em; }
    #links { list-style: none; padding: 0; }
    #link-count { color: #666; font-size: 0.9em; margin-bottom: 0.5rem; }
    .link { margin: 0.5rem 0; }
    .link .title { color: #0066cc; }
    .link .url { color: #888; font-size: 0.85em; margin-left: 0.5rem; }
    .link .added { color: #999; font-size: 0.85em; }
    .link .tags { margin-left: 0.5rem; }
    .link .tag { color: #666; font-size: 0.9em; text-decoration: none; }
    .link .tag:hover { text-decoration: underline; }
    .empty { color: #999; font-style: italic; }
    .tag-list { list-style: none; padding: 0; }
    .tag-list li { margin: 0.5rem 0; }
    .tag-list a { color: #0066cc; text-decoration: none; font-size: 1.1em; }
    .tag-list a:hover { text-decoration: underline; }
    .tag-list .count { color: #888; margin-left: 0.5rem; }
    #add-form { margin-bottom: 1.5rem; display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap; }
    #add-form input[type="text"] { flex: 1; padding: 0.5rem; font-size: 1rem; border: 1px solid #ccc; border-radius: 4px; min-width: 150px; }
    #add-form button { padding: 0.5rem 1rem; font-size: 1rem; cursor: pointer; border: 1px solid #ccc; border-radius: 4px; background: #f5f5f5; }
    #add-form button:hover { background: #e5e5e5; }
    #submit-status { font-size: 0.85em; margin-left: 0.5rem; }
    .status-success { color: #2a2; }
    .status-error { color: #c22; }
    footer { margin-top: 3rem; padding-top: 1rem; border-top: 1px solid #eee; font-size: 0.85em; color: #666; display: flex; justify-content: space-between; }
    footer a { color: #666; }
    #version { font-size: 0.75em; color: #999; }
    #sort-controls { margin-bottom: 1rem; font-size: 0.9em; }
    #sort-controls select { padding: 0.25rem; font-size: 0.9em; }
    .link .hide-btn { color: #ccc; cursor: pointer; margin-left: 0.5rem; font-size: 0.85em; }
    .link .hide-btn:hover { color: #c22; }
  </style>
</head>
<body>
  <header>
    <h1><a href="/">trove</a></h1>
    <div id="auth-container">
      <button id="auth-btn" onclick="handleAuth()">Sign in</button>
    </div>
  </header>

  <div id="add-form">
    <input type="text" id="link-url" placeholder="https://..." />
    <input type="text" id="link-tags" placeholder="Tags (space-separated)" />
    <input type="text" id="link-notes" placeholder="Notes (optional)" />
    <button id="submit-btn" onclick="submitLink()">Add</button>
    <span id="submit-status"></span>
  </div>

  <div id="sort-controls" style="display: none;">
    Sort: <select id="sort-select" onchange="applySort()">
      <option value="newest">Newest first</option>
      <option value="oldest">Oldest first</option>
      <option value="alpha">Alphabetical</option>
      <option value="random">Random</option>
    </select>
  </div>
  <div id="link-count"></div>
  <div id="links"></div>

  <script>
    // Parse path or hash to get tag filters: /foo/bar or #foo/bar → ['foo', 'bar']
    // Tags starting with '-' are exclusions: /foo/-bar → include 'foo', exclude 'bar'
    function getTagFilters() {
      const hash = window.location.hash.replace(/^#\/?/, '');
      if (hash) {
        return hash.split('/').filter(s => s.length > 0);
      }
      return window.location.pathname
        .split('/')
        .filter(segment => segment.length > 0 && segment !== 'index.html');
    }

    // Parse tags from space-separated string to array
    const parseTags = (tags) => tags ? tags.split(' ').filter(t => t) : [];

    // Hidden links stored in localStorage
    const HIDDEN_KEY = 'trove_hidden_links';
    const getHiddenLinks = () => JSON.parse(localStorage.getItem(HIDDEN_KEY) || '[]');
    const hideLink = (url) => {
      const hidden = getHiddenLinks();
      if (!hidden.includes(url)) {
        hidden.push(url);
        localStorage.setItem(HIDDEN_KEY, JSON.stringify(hidden));
      }
    };

    // Store current filtered links for re-sorting
    let currentLinks = [];
    // Store current page tags to exclude from display
    let currentPageTags = [];

    const formatDate = (iso) => {
      const d = new Date(iso);
      const now = new Date();
      const pad = n => String(n).padStart(2, '0');

      // Smart date formatting: show only as much precision as needed
      if (d.getFullYear() !== now.getFullYear()) {
        // Different year: show YYYY
        return String(d.getFullYear());
      } else if (d.getMonth() !== now.getMonth()) {
        // Same year, different month: show MMM DD
        const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        return `${months[d.getMonth()]} ${d.getDate()}`;
      } else if (d.getDate() !== now.getDate()) {
        // Same month, different day: show DD
        return String(d.getDate());
      } else {
        // Same day: show HH:MM
        return `${pad(d.getHours())}:${pad(d.getMinutes())}`;
      }
    };

    // Normalize URL: prepend https:// if missing protocol
    const normalizeUrl = (url) => {
      if (url && !url.includes('://')) {
        return 'https://' + url;
      }
      return url;
    };

    function sortLinks(links, sortBy) {
      const sorted = [...links];
      switch (sortBy) {
        case 'oldest':
          sorted.sort((a, b) => (a.added || '').localeCompare(b.added || ''));
          break;
        case 'alpha':
          sorted.sort((a, b) => (a.title || a.url).toLowerCase().localeCompare((b.title || b.url).toLowerCase()));
          break;
        case 'random':
          for (let i = sorted.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [sorted[i], sorted[j]] = [sorted[j], sorted[i]];
          }
          break;
        case 'newest':
        default:
          sorted.sort((a, b) => (b.added || '').localeCompare(a.added || ''));
          break;
      }
      return sorted;
    }

    function renderLinks(links) {
      const container = document.getElementById('links');
      container.innerHTML = links.map(link => {
        const tags = parseTags(link.tags).filter(t => !currentPageTags.includes(t));
        let domain = link.url;
        try { domain = new URL(link.url).hostname.replace(/^www\./, ''); } catch {}
        return `
        <div class="link"
             data-url="${link.url}"
             data-added="${link.added || ''}"
             ${link.title ? `data-title="${link.title.replace(/"/g, '&quot;')}"` : ''}
             ${tags.length ? `data-tags="${tags.join(' ')}"` : ''}>
          <a href="${link.url}" target="_blank">
            <span class="title">${link.title || link.url}</span>
          </a>
          <span class="url">${domain}</span>
          ${link.added ? `<span class="added">${formatDate(link.added)}</span>` : ''}
          ${tags.length ? `<span class="tags">${tags.map(t => `<a href="/${t}" class="tag">#${t}</a>`).join(' ')}</span>` : ''}
          <span class="hide-btn" onclick="handleHide('${link.url.replace(/'/g, "\\'")}', this)">x</span>
        </div>`;
      }).join('');
    }

    function applySort() {
      const sortBy = document.getElementById('sort-select').value;
      const sorted = sortLinks(currentLinks, sortBy);
      renderLinks(sorted);
    }

    function handleHide(url, btn) {
      hideLink(url);
      btn.closest('.link').remove();
      currentLinks = currentLinks.filter(l => l.url !== url);
    }

    async function loadLinks() {
      const container = document.getElementById('links');
      const sortControls = document.getElementById('sort-controls');
      const tagFilters = getTagFilters();

      // Pre-populate tags input with current filters (exclude negated tags)
      const tagsInput = document.getElementById('link-tags');
      const includeTags = tagFilters.filter(t => !t.startsWith('-'));
      if (tagsInput) tagsInput.value = includeTags.join(' ');

      // Update heading to show active filters
      if (tagFilters.length > 0) {
        document.querySelector('h1 a').textContent = tagFilters.map(t =>
          t.startsWith('-') ? `-#${t.slice(1)}` : `#${t}`
        ).join(' ');
        document.title = tagFilters.join('/') + ' - trove';
      }

      try {
        const response = await fetch('/trove.jsonl');
        const text = await response.text();
        const allLinks = text.trim().split('\n').filter(line => line).map(line => {
          const link = JSON.parse(line);
          link.url = normalizeUrl(link.url);
          return link;
        });

        // Front page: show tag list with counts (no sort controls)
        if (tagFilters.length === 0) {
          sortControls.style.display = 'none';
          const tagCounts = {};
          allLinks.forEach(link => {
            parseTags(link.tags).forEach(tag => {
              tagCounts[tag] = (tagCounts[tag] || 0) + 1;
            });
          });

          const sortedTags = Object.entries(tagCounts)
            .sort((a, b) => b[1] - a[1]);

          if (sortedTags.length === 0) {
            container.innerHTML = '<div class="empty">No tags found.</div>';
            return;
          }

          container.innerHTML = '<ul class="tag-list">' + sortedTags.map(([tag, count]) =>
            `<li><a href="/${tag}">#${tag}</a><span class="count">(${count})</span></li>`
          ).join('') + '</ul>';
          return;
        }

        // Filter links by tags (must have ALL included tags, none of excluded tags)
        const excludeTags = tagFilters.filter(t => t.startsWith('-')).map(t => t.slice(1));
        const hiddenLinks = getHiddenLinks();
        const links = allLinks.filter(link => {
          if (hiddenLinks.includes(link.url)) return false;
          const linkTags = parseTags(link.tags);
          const hasAllIncluded = includeTags.every(tag => linkTags.includes(tag));
          const hasNoneExcluded = excludeTags.every(tag => !linkTags.includes(tag));
          return hasAllIncluded && hasNoneExcluded;
        });

        if (links.length === 0) {
          sortControls.style.display = 'none';
          container.innerHTML = '<div class="empty">No links found.</div>';
          return;
        }

        // Show sort controls, link count, and render sorted links
        sortControls.style.display = 'block';
        document.getElementById('link-count').textContent = `${links.length} link${links.length === 1 ? '' : 's'}`;
        currentLinks = links;
        currentPageTags = includeTags;
        const sortBy = document.getElementById('sort-select').value;
        const sorted = sortLinks(links, sortBy);
        renderLinks(sorted);
      } catch (err) {
        container.innerHTML = '<div class="empty">Failed to load links.</div>';
        console.error(err);
      }
    }

    loadLinks();
  </script>

  <!-- config for local dev; empty file in production -->
  <script src="/config.js" onerror=""></script>

  <!-- Google Identity Services -->
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <script>
    let accessToken = null;
    let tokenClient = null;

    function initGoogleAuth() {
      const clientId = window.GOOGLE_CLIENT_ID || '';
      if (!clientId) {
        document.getElementById('auth-btn').textContent = 'No OAuth configured';
        document.getElementById('auth-btn').disabled = true;
        return;
      }
      tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: clientId,
        scope: 'email',
        callback: (response) => {
          if (response.access_token) {
            accessToken = response.access_token;
            document.getElementById('auth-btn').textContent = 'Signed in';
            document.getElementById('auth-btn').disabled = true;
          }
        },
      });
    }

    function handleAuth() {
      if (tokenClient) {
        tokenClient.requestAccessToken();
      }
    }

    async function submitLink() {
      const urlInput = document.getElementById('link-url');
      const tagsInput = document.getElementById('link-tags');
      const notesInput = document.getElementById('link-notes');
      const status = document.getElementById('submit-status');
      const url = urlInput.value.trim();
      const tags = tagsInput.value.trim();
      const notes = notesInput.value.trim();

      if (!url) {
        status.textContent = 'Enter a URL';
        status.className = 'status-error';
        return;
      }

      if (!accessToken) {
        status.textContent = 'Sign in first';
        status.className = 'status-error';
        return;
      }

      status.textContent = 'Submitting...';
      status.className = '';

      try {
        const response = await fetch('/.netlify/functions/submit', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ url, tags, notes, googleToken: accessToken }),
        });

        const result = await response.json();

        if (response.ok) {
          status.textContent = 'Submitted!';
          status.className = 'status-success';
          urlInput.value = '';
          // Re-populate tags from current page filters
          const tagFilters = getTagFilters();
          tagsInput.value = tagFilters.filter(t => !t.startsWith('-')).join(' ');
          notesInput.value = '';
        } else {
          status.textContent = result.error || 'Failed';
          status.className = 'status-error';
        }
      } catch (e) {
        status.textContent = 'Network error';
        status.className = 'status-error';
      }
    }

    // Initialize auth when Google library loads
    window.addEventListener('load', () => {
      if (typeof google !== 'undefined') {
        initGoogleAuth();
      } else {
        // Library not loaded yet, wait for it
        const checkGoogle = setInterval(() => {
          if (typeof google !== 'undefined') {
            clearInterval(checkGoogle);
            initGoogleAuth();
          }
        }, 100);
      }
    });
  </script>

  <footer>
    <div>a <a href="https://saul.pw">saul.pw</a> project | <a href="/privacy">privacy policy</a></div>
    <div id="version"></div>
  </footer>
  <script>
    fetch('/version.txt')
      .then(r => r.text())
      .then(v => document.getElementById('version').textContent = 'v' + v.trim())
      .catch(() => {});
  </script>
</body>
</html>
